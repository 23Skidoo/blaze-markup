{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_HADDOCK ignore-exports #-}
-- |BlazeHTML is a library to produce HTML. It is faster than the @html@ package, it guarantees at compile time that the HTML is syntactically valid, and gives composites of elements and attributes and content the same semantics as primitive elements.  This module contains the general documentation, and the combinators for generating HTML.
--
-- Before beginning a systematic exposition of BlazeHtml, we provide enough rote material to experiment while following the rest of the documentation.
--
-- The simplest value in HTML is a plain string, such as @Hello, world!@, with no tags.  In BlazeHtml it is denoted
--
-- > text "Hello, world!"
--
-- /Remark./ 'text' escapes the characters in its argument.  & becomes @&amp;@, \< becomes @&lt;@, etc.  If you don't wish BlazeHtml to escape your text, use 'unescapedText' instead. /End Remark./
--
-- We postpone the details of rendering HTML, but to experiment with the library as you go use the 'putHtml' function, which writes any HTML generated by BlazeHtml to standard output.  For example, in GHCi,
--
-- > > :m +Text.BlazeHtml.Html
-- > > putHtml $ text "Hello, world!"
-- > Hello, world!
--
-- To use BlazeHtml in a module, import
--
-- > import BlazeHtml.Html
--
-- 'BlazeHtml.Html' includes functions like 'div', 'head', and 'span' which conflict with other functions.  You should adjust what functions you hide from 'BlazeHtml.Html' and 'Prelude' to your particular needs.
--
-- So much for preliminaries.  Let us turn to generating HTML.
--
-- HTML is a markup language.  It wraps chunks of text in a hierarchy of elements.  Aside from element attributes, which we will examine in the next section, encoding 
--
-- > <p>This is a <em>very</em> important paragraph.</p>
--
-- covers all of generating HTML.  Drawn as a hierarchy, it is
--
-- > p --- "This is a "
-- >    |- em - "very"
-- >    |- " important paragraph."
--
-- We need three functions
--
-- > text :: Html h => Text -> h
-- > p :: Html h => h -> h
-- > em :: Html h => h -> h
--
-- /Remark/. Why is 'Html' a typeclass?  One of the design criteria for BlazeHtml was speed, but what makes code fast depends on how it is used.  Making 'Html' a fixed type would restrict us to optimization for one set of conditions.  As a typeclass, we can specialize BlazeHtml for specific scenarios, but all HTML generation remains generic. /End Remark/
--
-- 'text' we saw already.  It makes chunks of text into HTML values.
--
-- 'p' and 'em', and every other element, have type 'Html h => h -> h'.  They take an 'Html' value and wraps it in an element.  So
--
-- > > putHtml $ em $ text "Hello, world!"
-- > <em>Hello, world!</em>
--
-- In our example HTML, 'em' contains only one value, which fits its type 'Html h => h -> h'.  'p' has the same type, but takes three values.  How does this work?
--
-- This situation occurs often enough to Haskell to have a definitive solution.  Instead of writing separate functions that do the same thing, but on inputs @a@ and @[a]@, we make the type into a monoid.  A monoid is any type with a sensible values corresponding to zero (denoted 'mempty'), and a way of "adding" values (denoted 'mappend').  The numbers 0, 1, 2, ... are the classical example of a monoid.  Lists are a monoid with @[]@ playing the role of zero and concatenation as addition.
--
-- 'Html' is a monoid with an empty chunk of text as zero and concatenation as addition.  The concatenation never adds whitespace.  We can pass the three chunks to 'p' by first adding them,
--
-- > p $ text "This is a " `mappend` (em $ text "very") `mappend` text " important paragraph."
--
-- BlazeHtml provides a combinator @(\</) :: Html h => (h -> h) -> [h] -> h@ for this ubiquitous pattern
--
-- > p </ [text "This is a ", em $ text "very", text " important paragraph"]
--
-- The semantics of '(</)' were chosen to permit defining composite elements that behave exactly like the primitive ones, as in
--
-- > remark :: Html h -> h -> h
-- > remark t = p </ [ strong $ text "Remark. ", t, strong $ text " End Remark." ]
--
-- then in GHCi,
--
-- > > putHtml $ remark $ text "This is a remark."
-- > <p><strong>Remark. </strong>This is a remark.<strong> End Remark.</strong></p>@
--
-- /Remark/. All of HTML's elements retain their name in BlazeHtml.  @\<strong>\<\/strong>@ is 'strong'; @\<div>\<\/div>@ is 'div'; etc.  Most have type 'Html h => h -> h', but not all.  'img', for example, has type @Html h => String -> String -> h -> h@ to set the @src@ and @alt@ attributes.  You will profit from looking over the types of all the standard elements. /End Remark/
--
-- With 'text', the element functions, and '(</)' you can construct the hierarchy of any HTML document.  We must now add attributes to element.
--
-- @p :: Html h => h -> h@ has no attributes.  A paragraph element with a set of attributes has the same time.  How do we turn one into the other?
--
-- First, all attributes in BlazeHtml have type 'Attribute', a synonym for @(Text,Text)@.  The first field is the attribute's key, the second it's value.  The library provides a combinator
--
-- > (<!) :: Html h => (h -> h) -> Attribute -> h -> h
--
-- which adds an attribute to an element, as in
--
-- > > putHtml $ p <! ("id","myparagraph") "Hello, world!"
-- > <p id="myparagraph">Hello, world!</p>
--
-- Very often you will want to set a list of attributes.  BlazeHtml provides a combinator '(<!:)' that differs from '(<!)' only in that it takes a list of attributes instead of a single attribute.  For example,
--
-- > > putHtml $ p <!: [("id","myparagraph"), ("style","color: green")] "Hello, world!"
-- > <p id="myparagraph" style="color: green">Hello, world!</p>
--
-- /Warning./ Attribute values added with '(<!)' are added verbatim.  There is no escaping.  To prevent security flaws, you should never, ever manually set attributes with dynamic data.  BlazeHtml provides attribute combinators like 'href' and 'charset' which take care of escaping data.  Use them instead. /End Warning./
--
-- '(<!)' operates on functions.  You may need to add attributes to an 'Html' value directly, for which BlazeHtml provides the 
-- 
-- > (!) :: Html h => h -> Attribute -> h
--
-- operator.  Again, there is an operator '(!:)' which takes a list of 'Attribute' instead of a single one.  For example,
--
-- > > putHtml $ (p $ text "Hello, world!") ! ("id","myparagraph") !: [("style","color: blue"), ("class", "ugly")]
-- > <p id="myparagraph" style="color: blue" class="ugly">Hello, world!</p>
--
-- /Warning./ If you add the same attribute twice to the same element, it will appear twice in that element.  BlazeHtml does no checking of uniqueness or merging of elements, since the correct behavior is not obvious.  Should an @id@ attribute be overridden?  Should multiple @class@ attributes be merged?  It is the user's responsibility to ensure their attribute lists are valid. /End Warning./
--
-- Unlike '(<!)', '(!)' has several corner cases you should be aware of.
--
-- First, 'Html' is a monoid, so its values may be a sequence of elements.  '(!)' adds attributes to each top level element of such compound values.  That is,
--
-- > > putHtml $ ul $ (li $ text "First item.") `mappend` (li $ text "Second item.") ! ("class","horatio")
-- > <ul><li class="horatio">First item.</li><li class="horatio">Second item.</li></ul>
--
-- Second, the value of @text "Hello, world!"@ is a valid argument for '(!)', but what does it mean to add attributes to a value with no elements?  In BlazeHtml, it does nothing.  The attributes are discarded and the text is unchanged.  Formally, it satisfies @text x ! a == text x@ for all @x :: Text@ and @a :: Attribute@ or @a :: [Attribute]@.
--
-- 'putHtml' let us explore HTML generation.  Now we must use the generated HTML.  To render HTML, we must have an instance of the 'Html' typeclass.  BlazeHtml provides several such renderers for different purposes.
--
-- Each renderer provides a function @render@/ModuleName/ ('renderHtmlText' in 'HtmlText', 'renderHtmlPretty' in 'HtmlPretty', etc.) which takes a value of type 'Html h => h'.  The exact type of the rendering function depends on the renderer since they need different parameters.  The current renderers in BlazeHtml are
--
--   ['HtmlIO'] performs an IO action on the resulting HTML text as it is built.
--
--   ['HtmlText'] produces the HTML as a 'Text' value.
--
--   ['HtmlPrettyText'] is identical to 'HtmlText', but puts newlines and indentation in the stream to make it easier to read.
--
-- See the description of the 'Html' typeclass for the details of implementing an instance of it.
--
-- The BlazeHtml library's modules fall in three categories.  'Text.BlazeHtml.Html', 'Text.BlazeHtml.XHtml', and 'Text.BlazeHtml.Xml' are the libraries users import.  They bear all the combinators and elements for their respective formats.  The renderers are all found in @Text.BlazeHtml.Render@, for example 'Text.BlazeHtml.Render.HtmlIO' and 'Text.BlazeHtml.Render.HtmlText'.  The modules under @Text.BlazeHtml.Internal@ contain the guts of the library.  'Text.BlazeHtml.Internal.Html' contains the 'Html' typeclass, and 'Text.BlazeHtml.Internal.Escaping' implements string escaping for the library.
--
-- Finally, here are some examples of pages encoded in BlazeHtml:
--
-- > html </ [ head </ [ link "stylesheet" "default.css"
-- >                   , title $ text "Hello!" ]
-- >         , body </ [ h1 $ text "Hello!"
-- >                   , p $ text "Welcome to BlazeHtml." ]]
--


module Text.BlazeHtml.Html
    ( module Text.BlazeHtml.Internal.Html
    	, text, unescapedText
      , a_, a
      , abbr
      , acronym
      , address
      , applet
      , area
      , b
      , base
      , basefont
      , bdo
      , big
      , blockquote
      , body
      , br
      , button
      , caption
      , center
      , cite
      , code
      , col
      , colgroup
      , dd
      , del
      , dfn
      , dir
      , div
      , dl
      , dt
      , em
      , fieldset
      , font
      , form
      , frame
      , frameset
      , h1
      , h2
      , h3
      , h4
      , h5
      , h6
      , head
      , hr
      , html
      , i
      , iframe
      , img_, img
      , input
      , ins
      , isindex
      , kbd
      , label
      , legend
      , li
      , link
      , map
      , menu
      , meta
      , noframes
      , noscript
      , object
      , ol
      , optgroup
      , option
      , p
      , param
      , pre
      , q
      , s
      , samp
      , script
      , select
      , small
      , span
      , strike
      , strong
      , style
      , sub
      , sup
      , table
      , tbody
      , td
      , textarea
      , tfoot
      , th
      , thead
      , title
      , tr
      , tt
      , u
      , ul
      , var
    ) where

import Prelude hiding (div, head, span, map)

import Text.BlazeHtml.Text (Text)
import Text.BlazeHtml.Internal.Html 
    hiding (modifyUnescapedAttributes, clearAttributes)
import Text.BlazeHtml.Internal.Escaping

-- | This is an auxiliary function to fix the type of attributes, because type
--   inference comes up with too general types.
attrs :: [(Text, Text)] -> [(Text, Text)]
attrs = id

-- | This is a function comparable to @attrs@, but supporting one argument.
attr :: (Text, Text) -> (Text, Text)
attr = id

-- | Create a chunk of text with no string escaping.
unescapedText :: (Html h) => Text -> h
unescapedText = renderUnescapedText

-- | Create an 'Html' value from a chunk of text, with proper string escaping.
text :: (Html h) => Text -> h
text = renderUnescapedText . escapeHtml

-- | Render an @a@ element.
--
-- > a "index.html"
-- | Render a @a@ element without any attributes
a_ :: (Html h)=> h -> h
a_ = renderElement "a"

a :: (Html h)=> Text -> h -> h
a href = a_ <! attr ("href", href)

-- | Render a @abbr@ element
abbr :: (Html h)=> h -> h
abbr = renderElement "abbr"

-- | Render a @acronym@ element
acronym :: (Html h)=> h -> h
acronym = renderElement "acronym"

-- | Render a @address@ element
address :: (Html h)=> h -> h
address = renderElement "address"

-- | Render a @applet@ element
applet :: (Html h)=> h -> h
applet = renderElement "applet"

-- | Render a @b@ element
b :: (Html h)=> h -> h
b = renderElement "b"

-- | Render a @bdo@ element
bdo :: (Html h)=> h -> h
bdo = renderElement "bdo"

-- | Render a @big@ element
big :: (Html h)=> h -> h
big = renderElement "big"

-- | Render a @blockquote@ element
blockquote :: (Html h)=> h -> h
blockquote = renderElement "blockquote"

-- | Render a @body@ element
body :: (Html h)=> h -> h
body = renderElement "body"

-- | Render a @button@ element
button :: (Html h)=> h -> h
button = renderElement "button"

-- | Render a @caption@ element
caption :: (Html h)=> h -> h
caption = renderElement "caption"

-- | Render a @center@ element
center :: (Html h)=> h -> h
center = renderElement "center"

-- | Render a @cite@ element
cite :: (Html h)=> h -> h
cite = renderElement "cite"

-- | Render a @code@ element
code :: (Html h)=> h -> h
code = renderElement "code"

-- | Render a @colgroup@ element
colgroup :: (Html h)=> h -> h
colgroup = renderElement "colgroup"

-- | Render a @dd@ element
dd :: (Html h)=> h -> h
dd = renderElement "dd"

-- | Render a @del@ element
del :: (Html h)=> h -> h
del = renderElement "del"

-- | Render a @dfn@ element
dfn :: (Html h)=> h -> h
dfn = renderElement "dfn"

-- | Render a @dir@ element
dir :: (Html h)=> h -> h
dir = renderElement "dir"

-- | Render a @div@ element
div :: (Html h)=> h -> h
div = renderElement "div"

-- | Render a @dl@ element
dl :: (Html h)=> h -> h
dl = renderElement "dl"

-- | Render a @dt@ element
dt :: (Html h)=> h -> h
dt = renderElement "dt"

-- | Render a @em@ element
em :: (Html h)=> h -> h
em = renderElement "em"

-- | Render a @fieldset@ element
fieldset :: (Html h)=> h -> h
fieldset = renderElement "fieldset"

-- | Render a @font@ element
font :: (Html h)=> h -> h
font = renderElement "font"

-- | Render a @form@ element
form :: (Html h)=> h -> h
form = renderElement "form"

-- | Render a @frameset@ element
frameset :: (Html h)=> h -> h
frameset = renderElement "frameset"

-- | Render a @h1@ element
h1 :: (Html h)=> h -> h
h1 = renderElement "h1"

-- | Render a @h2@ element
h2 :: (Html h)=> h -> h
h2 = renderElement "h2"

-- | Render a @h3@ element
h3 :: (Html h)=> h -> h
h3 = renderElement "h3"

-- | Render a @h4@ element
h4 :: (Html h)=> h -> h
h4 = renderElement "h4"

-- | Render a @h5@ element
h5 :: (Html h)=> h -> h
h5 = renderElement "h5"

-- | Render a @h6@ element
h6 :: (Html h)=> h -> h
h6 = renderElement "h6"

-- | Render a @head@ element
head :: (Html h)=> h -> h
head = renderElement "head"

-- | Render a @html@ element
html :: (Html h)=> h -> h
html = renderElement "html"

-- | Render a @i@ element
i :: (Html h)=> h -> h
i = renderElement "i"

-- | Render a @iframe@ element
iframe :: (Html h)=> h -> h
iframe = renderElement "iframe"

-- | Render a @ins@ element
ins :: (Html h)=> h -> h
ins = renderElement "ins"

-- | Render a @kbd@ element
kbd :: (Html h)=> h -> h
kbd = renderElement "kbd"

-- | Render a @label@ element
label :: (Html h)=> h -> h
label = renderElement "label"

-- | Render a @legend@ element
legend :: (Html h)=> h -> h
legend = renderElement "legend"

-- | Render a @li@ element
li :: (Html h)=> h -> h
li = renderElement "li"

-- | Render a @map@ element
map :: (Html h)=> h -> h
map = renderElement "map"

-- | Render a @menu@ element
menu :: (Html h)=> h -> h
menu = renderElement "menu"

-- | Render a @noframes@ element
noframes :: (Html h)=> h -> h
noframes = renderElement "noframes"

-- | Render a @noscript@ element
noscript :: (Html h)=> h -> h
noscript = renderElement "noscript"

-- | Render a @object@ element
object :: (Html h)=> h -> h
object = renderElement "object"

-- | Render a @ol@ element
ol :: (Html h)=> h -> h
ol = renderElement "ol"

-- | Render a @optgroup@ element
optgroup :: (Html h)=> h -> h
optgroup = renderElement "optgroup"

-- | Render a @option@ element
option :: (Html h)=> h -> h
option = renderElement "option"

-- | Render a @p@ element
p :: (Html h)=> h -> h
p = renderElement "p"

-- | Render a @pre@ element
pre :: (Html h)=> h -> h
pre = renderElement "pre"

-- | Render a @q@ element
q :: (Html h)=> h -> h
q = renderElement "q"

-- | Render a @s@ element
s :: (Html h)=> h -> h
s = renderElement "s"

-- | Render a @samp@ element
samp :: (Html h)=> h -> h
samp = renderElement "samp"

-- | Render a @script@ element
script :: (Html h)=> h -> h
script = renderElement "script"

-- | Render a @select@ element
select :: (Html h)=> h -> h
select = renderElement "select"

-- | Render a @small@ element
small :: (Html h)=> h -> h
small = renderElement "small"

-- | Render a @span@ element
span :: (Html h)=> h -> h
span = renderElement "span"

-- | Render a @strike@ element
strike :: (Html h)=> h -> h
strike = renderElement "strike"

-- | Render a @strong@ element
strong :: (Html h)=> h -> h
strong = renderElement "strong"

-- | Render a @style@ element
style :: (Html h)=> h -> h
style = renderElement "style"

-- | Render a @sub@ element
sub :: (Html h)=> h -> h
sub = renderElement "sub"

-- | Render a @sup@ element
sup :: (Html h)=> h -> h
sup = renderElement "sup"

-- | Render a @table@ element
table :: (Html h)=> h -> h
table = renderElement "table"

-- | Render a @tbody@ element
tbody :: (Html h)=> h -> h
tbody = renderElement "tbody"

-- | Render a @td@ element
td :: (Html h)=> h -> h
td = renderElement "td"

-- | Render a @textarea@ element
textarea :: (Html h)=> h -> h
textarea = renderElement "textarea"

-- | Render a @tfoot@ element
tfoot :: (Html h)=> h -> h
tfoot = renderElement "tfoot"

-- | Render a @th@ element
th :: (Html h)=> h -> h
th = renderElement "th"

-- | Render a @thead@ element
thead :: (Html h)=> h -> h
thead = renderElement "thead"

-- | Render a @title@ element
title :: (Html h)=> h -> h
title = renderElement "title"

-- | Render a @tr@ element
tr :: (Html h)=> h -> h
tr = renderElement "tr"

-- | Render a @tt@ element
tt :: (Html h)=> h -> h
tt = renderElement "tt"

-- | Render a @u@ element
u :: (Html h)=> h -> h
u = renderElement "u"

-- | Render a @ul@ element
ul :: (Html h)=> h -> h
ul = renderElement "ul"

-- | Render a @var@ element
var :: (Html h)=> h -> h
var = renderElement "var"


-- | Render a @area@ leaf element.
area :: (Html h)=> h
area = renderLeafElement "area"

-- | Render a @base@ leaf element.
base :: (Html h)=> h
base = renderLeafElement "base"

-- | Render a @basefont@ leaf element.
basefont :: (Html h)=> h
basefont = renderLeafElement "basefont"

-- | Render a @br@ leaf element.
br :: (Html h)=> h
br = renderLeafElement "br"

-- | Render a @col@ leaf element.
col :: (Html h)=> h
col = renderLeafElement "col"

-- | Render a @frame@ leaf element.
frame :: (Html h)=> h
frame = renderLeafElement "frame"

-- | Render a @hr@ leaf element.
hr :: (Html h)=> h
hr = renderLeafElement "hr"

-- | Render a @img@ leaf element, without any attribute
img_ :: (Html h)=> h
img_ = renderLeafElement "img"

-- | Render an @img@ element with mandatory data
img :: (Html h)=> Text -> Text -> h
img src alt = img_ !: attrs [("src", src), ("alt", alt)]

-- | Render a @input@ leaf element.
input :: (Html h)=> h
input = renderLeafElement "input"

-- | Render a @isindex@ leaf element.
isindex :: (Html h)=> h
isindex = renderLeafElement "isindex"

-- | Render a @link@ leaf element.
link :: (Html h)=> h
link = renderLeafElement "link"

-- | Render a @meta@ leaf element.
meta :: (Html h)=> h
meta = renderLeafElement "meta"

-- | Render a @param@ leaf element.
param :: (Html h)=> h
param = renderLeafElement "param"

