{-# LANGUAGE TypeSynonymInstances #-}
module HtmlProperties where

import Test.QuickCheck
import Data.Monoid
import Text.BlazeHtml.Text (Text)
import qualified Text.BlazeHtml.Text as T
import Text.BlazeHtml.Internal.Html
import Text.BlazeHtml.Render.HtmlIO
import Text.BlazeHtml.Render.HtmlText
import Text.BlazeHtml.Render.HtmlPrettyText
import Text.BlazeHtml.Render.HtmlByteString
import System.IO
import System.IO.Unsafe (unsafePerformIO)

-- Must implement an Eq instance for each Html instance we test
instance Eq HtmlText where
    a == b = htmlText a == htmlText b

instance Eq HtmlIO where
    a == b = unsafePerformIO $ fileCompare a b
      where
        fileCompare a b = do
            -- Output the HTML to temp files
            (aname, ahandle) <- openTempFile "/tmp" "htmliotest.html"
            htmlIO ahandle a
            hFlush ahandle
            (bname, bhandle) <- openTempFile "/tmp" "htmliotest.html"
            htmlIO bhandle b
            hFlush bhandle
            -- Read in the resulting data and compare it
            adata <- hGetContents ahandle
            hClose ahandle
            bdata <- hGetContents bhandle
            hClose bhandle
            return (adata == bdata)

instance Eq HtmlPrettyText where
    a == b = htmlPrettyText a == htmlPrettyText b

instance Eq HtmlByteString where
    a == b = htmlByteString a == htmlByteString b

newtype SpecialChar = SC { unSC :: Char } deriving Show
instance Arbitrary SpecialChar where
   arbitrary = do 
      x <- oneof [choose ('\0','\55295'), choose ('\57344','\1114111')]
      return (SC x)

instance Arbitrary Text where
    arbitrary     = T.pack `fmap` arbitrary

-- The output of these Arbitrary instances can be examined using the sample'
-- function, for example:
--
-- > sample' arbitrary :: IO [Text]

-- Quickcheck property definitions

prop_RenderEmpty :: (Html h, Eq h) => h -> Bool
prop_RenderEmpty h = unescapedText mempty == h

prop_RenderDistrib :: (Html h, Eq h) => h -> Text -> Text -> Bool
prop_RenderDistrib h t1 t2 = left == right
  where
    left = h `mappend` unescapedText t1 `mappend` unescapedText t2
    right = h `mappend` unescapedText (t1 `mappend` t2)

prop_SetAttribUnescaped :: (Html h, Eq h) => h -> [Attribute] -> Text -> Bool
prop_SetAttribUnescaped h a t = left == right
  where
    left = h `mappend` setUnescapedAttributes a (unescapedText t)
    right = h `mappend` (unescapedText t)

prop_AddAttribUnescaped :: (Html h, Eq h) => h -> [Attribute] -> Text -> Bool
prop_AddAttribUnescaped h a t = left == right
  where
    left = h `mappend` addAttributable a (unescapedText t)
    right = h `mappend` (unescapedText t)

-- The Html object passed in MUST have an outer tag, so attributes can be set
prop_SetAttribOverwrite :: (Html h, Eq h) => h -> [Attribute] -> [Attribute] -> Text -> Bool
prop_SetAttribOverwrite h a1 a2 t = left == right
  where
    left = setUnescapedAttributes a1 (setUnescapedAttributes a2 h)
    right = setUnescapedAttributes a2 h

-- Example of collecting the data generated by the Arbitrary instance:
--
-- prop_SetAttribOverwrite :: (Html h, Eq h) => h -> [Attribute] -> [Attribute] -> Text -> Property
-- prop_SetAttribOverwrite h a1 a2 t = collect t $ left == right
--   where
--     left = setUnescapedAttributes a1 (setUnescapedAttributes a2 h)
--     right = setUnescapedAttributes a2 h

-- The Html object passed in MUST have an outer tag, so attributes can be set
prop_AddSetAttribOverwrite :: (Html h, Eq h) => h -> [Attribute] -> [Attribute] -> Text -> Bool
prop_AddSetAttribOverwrite h a1 a2 t = left == right
  where
    left = addAttributable a1 (setUnescapedAttributes a2 h)
    right = setUnescapedAttributes a2 h


prop_AddAddAttrib :: (Html h, Eq h) => h -> [Attribute]-> [Attribute] -> Text -> Bool
prop_AddAddAttrib h a1 a2 t = left == right
  where
    left = addAttributable a1 (addAttributable a2 h)
    right = addAttributable (a2 `mappend` a1) h

-- Utility functions
orangeAttribs = [(T.pack("orange"), T.pack("mandarin"))]
appleAttribs = [(T.pack("apple"), T.pack("bramley"))]

pHtmlText :: HtmlText
pHtmlText = leafElement $ T.pack "p"

pHtmlIO :: HtmlIO
pHtmlIO = leafElement $ T.pack "p"

pHtmlPrettyText :: HtmlPrettyText
pHtmlPrettyText = leafElement $ T.pack "p"

pHtmlByteString :: HtmlByteString
pHtmlByteString = leafElement $ T.pack "p"

runHtmlTests empty pelem = sequence $ collectTests empty pelem

collectTests empty pelem = 
    [quickCheck $ prop_RenderEmpty empty
    ,quickCheck $ prop_RenderDistrib empty
    ,quickCheck $ prop_SetAttribUnescaped empty orangeAttribs
    ,quickCheck $ prop_AddAttribUnescaped empty orangeAttribs
    ,quickCheck $ prop_SetAttribOverwrite pelem orangeAttribs appleAttribs
    ,quickCheck $ prop_AddSetAttribOverwrite pelem orangeAttribs appleAttribs
    ,quickCheck $ prop_AddAddAttrib pelem orangeAttribs appleAttribs]
     
runTests = do
    runHtmlTests (mempty :: HtmlText) pHtmlText
    runHtmlTests (mempty :: HtmlIO) pHtmlIO
    runHtmlTests (mempty :: HtmlPrettyText) pHtmlPrettyText
    runHtmlTests (mempty :: HtmlByteString) pHtmlByteString
 
printTests = do
    putStrLn $ T.unpack $ htmlText $ setUnescapedAttributes orangeAttribs pHtmlText
    putStrLn $ T.unpack $ htmlText $ setUnescapedAttributes appleAttribs (setUnescapedAttributes orangeAttribs pHtmlText)
    putStrLn $ T.unpack $ htmlText $ addAttributable (appleAttribs `mappend` orangeAttribs) pHtmlText
