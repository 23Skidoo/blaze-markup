* Pulling ourselves up by our bootstraps

BlazeHTML is a library to produce HTML.  It is faster than programs which manually assemble HTML from strings, it guarantees at compile time that the HTML is valid, and gives composites of elements and attributs and content the same semantics as primitive elements.  This section provides enough rote material to experiment while following the systematic exposition starting in the next section.

The simplest value in HTML is a plain string, such as @Hello, world!@, with no tags.  In BlazeHtml it is denoted

> text "Hello, world!"

We postpone the details of rendering HTML, but to experiment with the library as you go use the 'putHtml' function, which writes any HTML generated by BlazeHtml to standard output.  For example, in GHCi,

> > :m +Text.BlazeHtml.Html
> > putHtml $ text "Hello, world!"
> Hello, world!

So much for preliminaries.  Let us turn to generating HTML.

* Elements and nesting

HTML is a markup language.  It wraps chunks of text in a hierarchy of elements.  Aside from element attributes, which we will examine in the next section, encoding 

> <p>This is a <em>very</em> important paragraph.</p>

covers all of generating HTML.  Drawn as a hierarchy, it is

@
p --- "This is a "
   |- em - "very"
   |- " important paragraph."
@

We need three functions

> text :: Html h => Text -> h
> p :: Html h => h -> h
> em :: Html h => h -> h

/Remark/. Why is 'Html' a typeclass?  One of the design criteria for BlazeHtml was speed, but what makes code fast depends on how it is used.  Making 'Html' a fixed type would restrict us to optimization for one set of conditions.  As a typeclass, we can specialize BlazeHtml for specific scenarios, but all HTML generation remains generic. /End Remark/

'text' we saw already.  It makes chunks of text into HTML values.

'p' and 'em', and every other element, have type 'Html h => h -> h'.  They take an 'Html' value and wraps it in an element.  So

> > putHtml $ em $ text "Hello, world!"
> <em>Hello, world!</em>

In our example HTML, 'em' contains only one value, which fits its type 'Html h => h -> h'.  'p' has the same type, but takes three values.  How does this work?

This situation occurs often enough to Haskell to have a definitive solution.  Instead of writing separate functions that do the same thing, but on inputs 'a' and '[a]', we make the type into a monoid.  A monoid is any type with a sensible values corresponding to zero (denoted 'mzero'), and a way of "adding" values (denoted 'mappend').  The numbers 0, 1, 2, ... are the classical example of a monoid.  Lists are a monoid with @[]@ playing the role of zero and concatenation as addition.

'Html' is a monoid with an empty chunk of text as zero and concatenation as addition.  We can pass the three chunks to 'p' by first adding them,

> p $ text "This is a " `mappend` (em $ text "very") `mappend` text " important paragraph."

BlazeHtml provides a combinator @(</) :: Html h => (h -> h) -> [h] -> h@ for this ubiquitous pattern

> p </ [text "This is a ", em $ text "very", text " important paragraph"]

The semantics of '(</)' were chosen to permit defining composite elements that behave exactly like the primitive ones, as in

> remark :: Html h -> h -> h
> remark t = p </ [ strong $ text "Remark.", t, strong $ text " End Remark." ]

then in GHCi,

> > putHtml $ remark $ text "This is a remark."
> <p><strong>Remark. </strong> This is a remark.<strong> End Remark.</strong></p>@

/Remark/. All of HTML's elements retain their name in BlazeHtml.  @\<strong>\<\/strong>@ is 'strong'; @\<div>\<\/div>@ is 'div'; etc.  Most have type 'Html h => h -> h', but not all.  'img', for example, has type @Html h => String -> String -> h -> h@ to set the @src@ and @alt@ attributes.  You will profit from looking over the types of all the standard elements. /End Remark/

With 'text', the element functions, and '(</)' you can construct the hierarchy of any HTML document.  We must now add attributes to element.

* Adding attributes

@p :: Html h => h -> h@ has no attributes.  A paragraph element with a set of attributes has the same time.  How do we turn one into the other?

First, all attributes in BlazeHtml have type 'Attribute', a synonym for @(Text,Text)@.  The first field is the attribute's key, the second it's value.  The library provides a combinator

> (<!) :: Html h => (h -> h) -> Attribute -> h -> h

which adds an attribute to an element, as in

> > putHtml $ p <! ("id","myparagraph") "Hello, world!"
> <p id="myparagraph">Hello, world!</p>

Very often you will want to set a list of attributes.  The type above for '(<!)' is wrong; it is actually overloaded over attributes.  You can call it with a single attribute, or a list of them, as in

> > putHtml $ p <! [("id","myparagraph"), ("style","color: green")] "Hello, world!"
> <p id="myparagraph" style="color: green">Hello, world!</p>

/Warning./ Attribute values added with '(<!)' are added verbatim.  There is no escaping.  To prevent security flaws, you should never, ever manually set attributes with dynamic data.  BlazeHtml provides attribute combinators like 'href' and 'charset' which take care of escaping data.  Use them instead.  /End Warning./

'(<!)' operates on functions.  You may need to add attributes to an 'Html' value directly, for which BlazeHtml provides the '(!)' @:: Html h => h -> Attribute -> h@ operator.  This type is again incorrect: '(!)', like '(<!)', is overloaded to accept 'Attribute' and '[Attribute]'.  For example,

> > putHtml $ (p $ text "Hello, world!") ! ("id","myparagraph") ! [("style","color: blue"), ("class", "ugly")]
> <p id="myparagraph" style="color: blue" class="ugly">Hello, world!</p>

/Warning./ If you add the same attribute twice to the same element, it will appear twice in that element.  BlazeHtml does no checking of uniqueness or merging of elements, since the correct behavior is not obvious.  Should an @id@ attribute be overridden?  Should multiple @class@ attributes be merged?  It is the user's responsibility to ensure their attribute lists are valid. /End Warning./

Unlike '(<!)', '(!)' has several corner cases you should be aware of.

First, 'Html' is a monoid, so its values may be a sequence of elements.  '(!)' adds attributes to each top level element of such compound values.  That is,

> > putHtml $ ul $ (li $ text "First item.") `mappend` (li $ text "Second item.") ! ("class","horatio")
> <ul><li class="horatio">First item.</li><li class="horatio">Second item.</li></ul>

Second, the value of @text "Hello, world!"@ is a valid argument for '(!)', but what does it mean to add attributes to a value with no elements?  In BlazeHtml, it does nothing.  The attributes are discarded and the text is unchanged.  Formally, it satisfies @text x ! a == text x@ for all @x :: Text@ and @a :: Attribute@ or @a :: [Attribute]@.

