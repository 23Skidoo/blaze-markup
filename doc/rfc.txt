% BlazeHtml RFC
% Simon Meier on behalf of the BlazeHtml team
% March 21, 2010

Introduction
============

This RFC describes the problem of efficiently generating Html responses for
sending them over the network and our proposed solution called 'BlazeHtml'.
The goal of this RFC is to gather feedback from the community about its design
before publishing the first implementation.

The outline of this document is as follows. First, we define the problem we
want to solve. Then, we describe the design that we developed and prototyped at
the ZuriHac'10. Finally, we discuss further open questions not related directly
to one of the library's components.


Problem
=======

The problem we want to solve is how to efficiently generate Html responses for
sending them over the network.

The above goal is the main motivation behind our work. However, we also pursue
the following additional goals:

  * static ensurance of syntactic well-formedness

  * light-weight syntax for specifying Html documents

  * support for other Html-like document formats (e.g.  XHtml, XML)

  * html documents should be first-class values; i.e. we want composability

As long as these goals don't conflict with our main goal, we try to satisfy
them as good as possible.


Proposed Solution
=================

Our solution called 'BlazeHtml' is based on a type-class 'Html' which defines a
set of core combinators. The instances of the 'Html' type-class correspond to
concrete output formats. We call such an instances a 'Renderer'. Using the core
combinators provided by the 'Html' type-class, we build concrete combinators
for the various flavours of Html-like documents on top.

In the following sections, we present the 'Html' type-class, the efficient
rendering instances, and the concrete document combinators.


Core Combinators
----------------

We fix the representation of text to the 'Text' type provided by 'Data.Text'.
An attributes is just a tuple of a text representing the key and a text
representing the value.

  type Attribute = (Text,Text)

We use a difference list of attributes to represent the accumulated attributes
to be applied to a html element.

  type AttributeManipulation = [Attribute] -> [Attribute]

An html document is a value of a type which is an instance of the 'Html'
type-class. 

  class Monoid h => Html h where
      -- | A text leaf -- no escaping is done.
      unescapedText    :: Text -> h
      -- | A leaf element with the given tag name.
      leafElement      :: Text -> h
      -- | A node element with the given tag and inner document.
      nodeElement      :: Text -> h -> h
      -- | Modify the attributes of the outermost elements in the .
      modifyAttributes ::
          (AttributeManipulation -> AttributeManipulation) -> h -> h

Let us give an example



-- | Any Html document is a monoid. Furthermore, the following equalities hold.
--
--    renderUnescapedText mempty = mempty
--
--    renderUnescapedText t1 `mappend` renderUnescapedText t2 = renderText (t1 `mappend` t2)
--
--    setUnescapedAttributes a (renderUnescapedText t) = renderUnescapedText t
--
--    addUnescapedAttributes a (renderUnescapedText t) = renderUnescapedText t
--
--    setUnescapedAttributes a1 (setUnescapedAttributes a2 h) = setUnescapedAttributes a2 h
--
--    addUnescapedAttributes a1 (setUnescapedAttributes a2 h) = setUnescapedAttributes a2 h
--
--    addUnescapedAttributes a1 (addUnescapedAttributes a2 h) = addUnescapedAttributes (a2 `mappend` a1) h 
--
--    renderElement t h = renderElement t (modifyUnescapedAttributes (const []) h)
--
---------------------------------------------------------------------
--
--    The following need to be tested in a more compreensive way:
--  
--    modifyUnescapedAttributes f (t1 `mappend` t2) = 
--    modifyUnescapedAttributes t1 `mappend` modifyUnescapedAttributes t2
--
--    modifyUnescapedAttributes f (modifyUnescapedAttributes g h) = modifyUnescapedAttributes (g.f) h
--
--    modifyUnescapedAttributes f (renderUnescapedText t) = renderUnescapedText t
--
--  Note that the interface below may be extended, if a performing
--  implementation requires it.
--

Rendering
---------



Specifying Html documents
-------------------------


Conclusion
==========


Acknowledgments
===============


