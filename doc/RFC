BlazeHtml RFC
=============

Introduction
------------

I was accepted as a student to Google Summer of Code for haskell.org. My task
is now to create a high-performance HTML generation library. We have chosen to
create a combinator library with a light-weight syntax called BlazeHtml.

In the past few weeks, I have been exploring the performance and design of
different drafts of this library. Now, the time has come to ask some questions
to the Haskell community -- and more specifically, the end users of the library,
and current users of other HTML generation libraries.

This document is mostly geared towards API design, and I would like to hear some
feedback on it: how do you want the API to look like?

HTML
----

Different versions of HTML are available. To sum up a few:

- XHTML
- HTML 4 Strict
- HTML 4 Transitional
- HTML 4 Frameset
- HTML 5
- ...

My first question is: what versions and variants should the library *at least*
support? Which HTML version would you preferably use?

Encoding
--------

We will support input from both `String` and `Data.Text` datatypes. These two
datatypes support all Unicode codepoints, so the output format should support
all Unicode codepoints, too. If the output format does not support all Unicode
codepoints, an extra escaping phase needs to happen. And so the second question
is: is this needed? Do we need support for "lossy" encodings, e.g. Latin-1? All
desktop browsers, and most mobile browsers support superior encodings like
UTF-8.

Also, I would like to pose some questions about the output format. There seem
to be two major options:

- Output to an encoded lazy ByteString. The advantage of this scenario is that
  the result can be sent over the network directly and efficiently.
- Output to a Text value. The advantage here is that we have a nicer separation
  of concerns (encoding would be separated from HTML generation).

The first option is faster. Should I sacrifice some speed to have the second
option as a possibility?

Syntax
------

BlazeHtml is going to use do-notation syntax by declaring a monad instance. An
example:

    page = html $ do
        head $ do
            title "Introduction page."
            link ! rel "stylesheet" ! type_ "text/css" ! href "screen.css"
        body $ do
            div ! id "header" $ "Syntax"
            p "This is an example of BlazeHtml syntax."
            ul $ forM_ [1, 2, 3] (li . string . show)

Take note: we use a monadic notation only for the do-syntax. The `>>=` operator
is defined but has no practical use -- we can use convenient functions like
`forM_`, though.

Because HTML is also a monoid, the above fragment would be equivalent to:

    page = html $ mconcat
        [ head $ mconcat
            [ title "Introduction page."
            , link ! rel "stylesheet" ! type_ "text/css" ! href "screen.css"
            ]
        , body $ mconcat
            [ div ! id "header" $ "Syntax"
            , p "This is an example of BlazeHtml syntax."
            , mconcat $ map (li . string . show) [1, 2, 3]
            ]
        ]

The syntax choice is then up to the end user. However, again a few questions
to the community:

Do you think `!` is a good operator for setting attributes? I made an initial
choice for `!` because the old HTML package uses this. However, this operator
looks more like array indexing. It is not too late to change this, suggestions
are very welcome.

How should multiple attributes be handled? In the above example, we used the `!`
again for the next attribute:

    link ! rel "stylesheet" ! type "text/css" ! href "screen.css"

Another option would be to define a variant that takes a list of attributes:

    link !> [rel "stylesheet", type "text/css", href "screen.css"]

Or, we could use a typeclass to give the `!` different uses, and thus have:

    link ! [rel "stylesheet", type "text/css", href "screen.css"]

The last option will, however, introduce a more complicated type for attributes,
and a little more overhead.

Modules
-------

Then, modules. How do you think modules should be called? We think that it
would make sense to have a separate module for attributes, because of the name
clashes (many elements names also appear as attributes). One option would be
to put the modules under:

    Text.Blaze.Html4.Strict
    Text.Blaze.Html4.Strict.Attributes

If we can drop "Blaze", we would get shorter names:

    Text.Html4.Strict
    Text.Html4.Strict.Attributes

What do you think about this? Should project names be in module names?

Pretty output
-------------

Should we include a pretty printer?

Naming conventions
------------------

Explain the naming conventions for the combinators and ask feedback.

Packaging
---------

How should the package be called? What is a good license to release it under?
